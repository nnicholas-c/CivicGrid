<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepgram Voice Agent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
</head>
<body>
    <h1>Deepgram Voice Agent Browser Demo</h1>
    <p>This is a demo of the Deepgram Voice Agent. It uses the <a href="https://developers.deepgram.com/reference/voice-agent-api/agent">Deepgram Voice Agent API</a>.</p>
    <p>Please enable your microphone in the browser to start the conversation.</p>
    <div>
        <button id="startCallButton">Start Call</button>
        <button id="endCallButton" disabled>End Call</button>
        <p id="errorMessage" style="color: red;"></p>
        <p id="statusMessage" style="color: blue;"></p>
    </div>
    <div>
        <label for="pictureInput">Upload picture (optional):</label>
        <input type="file" id="pictureInput" accept="image/*">
        <button id="uploadPictureButton" disabled>Send Picture</button>
        <span id="pictureStatus"></span>
    </div>
    <script>
        let socket;
        let mediaStream;
        let audioContext;
        let processor;
        let mediaStreamSource; // Track the source to prevent multiple creations
        let isConnected = false;
        let audioQueue = []; // Queue for managing incoming audio chunks
        let isPlaying = false; // Flag to track if we're currently playing audio
        let selectedDeviceId;
        let hasInitialized = false;
        let startButton;
        let endButton;
        let pictureStatus;
        let uploadButton;
        let pictureData = null;

        async function init() {
            if (hasInitialized) {
                return;
            }
            try {
                // Create audio context early
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new AudioContext({
                        sampleRate: 16000 // Match the Deepgram sample rate
                    });
                    console.log('AudioContext created with sample rate:', audioContext.sampleRate);
                }

                // Get microphone permission with specific constraints
                const constraints = {
                    audio: {
                        deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: false,  // Can be toggled
                        noiseSuppression: false,  // Can be toggled
                        autoGainControl: false,   // Can be toggled
                        latency: 0,              // Minimize latency
                        // Advanced constraints for better control
                        googEchoCancellation: false,
                        googAutoGainControl: false,
                        googNoiseSuppression: false,
                        googHighpassFilter: true
                    }
                };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Microphone access granted');

                // Connect to Socket.IO server
                socket = io({
                    path: '/socket.io',
                    forceNew: true
                });

                socket.on('connect', () => {
                    console.log('Connected to server');
                    isConnected = true;
                    const statusMsg = document.getElementById('statusMessage');
                    if (statusMsg) {
                        statusMsg.textContent = 'ðŸŸ¢ Connected - Microphone active';
                    }
                    startStreaming();
                    if (startButton) {
                        startButton.disabled = true;
                    }
                    if (endButton) {
                        endButton.disabled = false;
                    }
                });

                socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                    isConnected = false;
                    
                    // Cleanup on disconnect
                    if (processor) {
                        try {
                            processor.onaudioprocess = null;
                            processor.disconnect();
                        } catch (e) {
                            console.warn('Error disconnecting processor on disconnect:', e);
                        }
                        processor = null;
                    }
                    
                    hasInitialized = false;
                    if (startButton) {
                        startButton.disabled = false;
                    }
                    if (endButton) {
                        endButton.disabled = true;
                    }
                });

                socket.on('error', (data) => {
                    console.error('Server error details:', JSON.stringify(data, null, 2));
                });

                socket.on('agent_speaking', (data) => {
                    if (data.audio && data.audio.length > 0) {
                        const audioData = new Int16Array(data.audio);
                        audioQueue.push(audioData);
                        if (!isPlaying) {
                            playNextInQueue();
                        }
                    }
                });

                socket.on('agent_audio', (data) => {
                    console.log('Received agent_audio event, data length:', data.audio?.length);
                    if (data.audio && data.audio.length > 0) {
                        // Fast path: Convert array to Int16Array if needed
                        let audioData;
                        if (data.audio instanceof Int16Array) {
                            audioData = data.audio;
                        } else if (Array.isArray(data.audio)) {
                            audioData = new Int16Array(data.audio);
                        } else if (data.audio instanceof ArrayBuffer) {
                            audioData = new Int16Array(data.audio);
                        } else {
                            console.error('Invalid audio format received:', typeof data.audio);
                            return; // Skip invalid formats
                        }
                        
                        console.log('Queueing audio chunk, samples:', audioData.length);
                        // Immediately queue and play
                        audioQueue.push(audioData);
                        if (!isPlaying) {
                            playNextInQueue();
                        }
                    } else {
                        console.warn('Received agent_audio with no data');
                    }
                });

                hasInitialized = true;
            } catch (error) {
                console.error('Error initializing:', error);
                if (startButton) {
                    startButton.disabled = false;
                }
                if (endButton) {
                    endButton.disabled = true;
                }
                throw error;
            }
        }

        async function setupAudioProcessing() {
            const source = audioContext.createMediaStreamSource(mediaStream);

            // Gain control
            const gainNode = audioContext.createGain();

            // Analyzer for volume monitoring
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;

            // Worklet processor for better performance
            const processor = audioContext.createScriptProcessor(2048, 1, 1);

            // Connect the chain
            source
                .connect(gainNode)
                .connect(analyser)
                .connect(processor)
                .connect(audioContext.destination);

            return { gainNode, analyser, processor };
        }

        function startStreaming() {
            if (!mediaStream || !isConnected) return;
            
            // Prevent multiple calls from creating duplicate sources
            if (processor) {
                console.log('Already streaming, ignoring duplicate start');
                return;
            }

            try {
                // Create media stream source only once per stream
                mediaStreamSource = audioContext.createMediaStreamSource(mediaStream);

                // Create a worklet for better audio processing
                // Optimized for low latency while preventing underruns (768 = 48ms at 16kHz)
                const bufferSize = 768;
                processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                mediaStreamSource.connect(processor);
                processor.connect(audioContext.destination);

                // Send audio immediately without throttling for fastest response
                let audioSentCount = 0;
                processor.onaudioprocess = (e) => {
                    if (socket?.connected) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        const pcmData = convertFloatToPcm(inputData);
                        // Send as binary data immediately
                        socket.emit('audio_data', Array.from(pcmData));
                        
                        // Log every 100th chunk to verify streaming
                        audioSentCount++;
                        if (audioSentCount % 100 === 0) {
                            console.log(`Sent ${audioSentCount} audio chunks (${pcmData.length} samples each)`);
                        }
                    }
                };
            } catch (error) {
                console.error('Error starting audio stream:', error);
            }
        }

        function convertFloatToPcm(floatData) {
            const pcmData = new Int16Array(floatData.length);
            for (let i = 0; i < floatData.length; i++) {
                const s = Math.max(-1, Math.min(1, floatData[i]));
                pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return pcmData;
        }

        async function playNextInQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }

            isPlaying = true;
            const audioData = audioQueue.shift();

            try {
                // Ensure audio context is running (fast path)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Create buffer with correct sample rate for agent's audio (16000Hz from backend)
                // This must match the output sample rate in app.py configuration
                const sampleRate = 16000; // Matches backend output sample rate
                const buffer = audioContext.createBuffer(1, audioData.length, sampleRate);
                const channelData = buffer.getChannelData(0);

                // Convert Int16 to Float32 with proper scaling
                for (let i = 0; i < audioData.length; i++) {
                    // Normalize to [-1, 1] range
                    channelData[i] = audioData[i] / 32768.0;
                }

                // Create and configure source
                const source = audioContext.createBufferSource();
                source.buffer = buffer;

                // Optional: Add a gain node for volume control
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 1.0; // 100% volume, adjust as needed

                // Connect chain: source -> gain -> destination
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Handle playback completion
                source.onended = () => {
                    playNextInQueue(); // Play next chunk when current one ends
                };

                // Start playback immediately
                source.start(0);
            } catch (error) {
                console.error('Error playing audio:', error);
                isPlaying = false;
                playNextInQueue(); // Try next chunk if current fails
            }
        }

        function stopStreaming() {
            audioQueue = []; // Clear audio queue
            isPlaying = false;
            hasInitialized = false;
            
            // Properly cleanup audio processing chain
            if (processor) {
                try {
                    processor.onaudioprocess = null; // Remove handler
                    processor.disconnect();
                } catch (e) {
                    console.warn('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            // Cleanup media stream source
            if (mediaStreamSource) {
                try {
                    mediaStreamSource.disconnect();
                } catch (e) {
                    console.warn('Error disconnecting media stream source:', e);
                }
                mediaStreamSource = null;
            }
            
            // Close audio context properly
            if (audioContext && audioContext.state !== 'closed') {
                try {
                    audioContext.close();
                } catch (e) {
                    console.warn('Error closing audio context:', e);
                }
            }
            audioContext = null;
            
            // Stop all media tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => {
                    track.stop();
                });
                mediaStream = null;
            }
            
            isConnected = false;
        }

        function initializeVolumeMeter(analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function updateMeter() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                const volume = Math.min(100, average * 2);
                // Update UI with volume level
                requestAnimationFrame(updateMeter);
            }

            updateMeter();
        }

        async function getAudioDevices() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.filter(device => device.kind === 'audioinput');
        }

        async function handleStartCall() {
            if (startButton) {
                startButton.disabled = true;
            }
            if (endButton) {
                endButton.disabled = true;
            }
            try {
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                await init();
            } catch (error) {
                console.error('Failed to start call:', error);
                if (startButton) {
                    startButton.disabled = false;
                }
                if (endButton) {
                    endButton.disabled = true;
                }
            }
        }

        function handleEndCall() {
            // Stop streaming first
            stopStreaming();
            
            // Properly cleanup socket
            if (socket) {
                try {
                    // Remove all listeners before disconnecting
                    socket.removeAllListeners();
                    if (socket.connected) {
                        socket.disconnect();
                    }
                    socket = null;
                } catch (e) {
                    console.warn('Error cleaning up socket:', e);
                }
            }
            
            if (startButton) {
                startButton.disabled = false;
            }
            if (endButton) {
                endButton.disabled = true;
            }
        }

        async function handlePictureUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                pictureData = null;
                if (pictureStatus) {
                    pictureStatus.textContent = 'No file selected.';
                }
                if (uploadButton) {
                    uploadButton.disabled = true;
                }
                return;
            }

            const reader = new FileReader();
            reader.onload = async () => {
                pictureData = reader.result.split(',')[1] || '';
                if (pictureStatus) {
                    pictureStatus.textContent = pictureData ? 'Picture ready. Click "Send Picture".' : 'Could not read file.';
                }
                if (uploadButton) {
                    uploadButton.disabled = !pictureData;
                }
            };
            reader.onerror = () => {
                pictureData = null;
                if (pictureStatus) {
                    pictureStatus.textContent = 'Could not read file.';
                }
                if (uploadButton) {
                    uploadButton.disabled = true;
                }
            };
            reader.readAsDataURL(file);
        }

        async function handlePictureSend() {
            if (!pictureData) {
                if (pictureStatus) {
                    pictureStatus.textContent = 'Select a picture before sending.';
                }
                return;
            }

            if (uploadButton) {
                uploadButton.disabled = true;
            }
            if (pictureStatus) {
                pictureStatus.textContent = 'Uploading picture...';
            }

            try {
                const response = await fetch('/upload_picture', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ picture: pictureData })
                });
                if (!response.ok) {
                    throw new Error('Failed to upload picture');
                }
                if (pictureStatus) {
                    pictureStatus.textContent = 'Picture uploaded successfully.';
                }
            } catch (uploadError) {
                console.error('Error uploading picture:', uploadError);
                if (pictureStatus) {
                    pictureStatus.textContent = 'Picture upload failed.';
                }
            } finally {
                if (uploadButton) {
                    uploadButton.disabled = false;
                }
            }
        }

        // Initialize when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            startButton = document.getElementById('startCallButton');
            endButton = document.getElementById('endCallButton');
            const pictureInput = document.getElementById('pictureInput');
            pictureStatus = document.getElementById('pictureStatus');
            uploadButton = document.getElementById('uploadPictureButton');

            if (startButton) {
                startButton.addEventListener('click', handleStartCall);
            }
            if (endButton) {
                endButton.addEventListener('click', handleEndCall);
            }
            if (pictureInput) {
                pictureInput.addEventListener('change', handlePictureUpload);
            }
            if (uploadButton) {
                uploadButton.addEventListener('click', handlePictureSend);
            }
        });

        // Clean up when the page is closed
        window.onbeforeunload = () => {
            stopStreaming();
            if (socket) {
                socket.close();
            }
        };
    </script>
</body>
</html>